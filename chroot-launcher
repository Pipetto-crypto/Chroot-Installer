#!/bin/bash

#Variables

CONTAINERS_DIR=~/.chroot_installer/containers
CONFIG_DIR=~/.chroot_installer
LAST_ARGUMENT=$(echo "$@" | awk '{ print $NF }')
CHROOT_DIR=/data/local/mnt
INTERNAL_STORAGE=/sdcard
ANDROIDVERSION=$(getprop ro.build.version.release)
index=1
for var in "$@"
do
    argslist[$index]=$var
    index=$((index+1))
done
ISRUNNING=false


#check if busybox is available and if not exit

if [[ "$(su -c busybox)" =~ "not found" ]]
  then
      echo "Busybox not found, install busybox if you want to be able to launch your chroot"
      exit 0
  fi

#check if Android Version is 12 and set max phantom processes
if [ "$ANDROIDVERSION" == "12" ]
then
	if ! su -c device_config get activity_manager max_phantom_processes | grep -q "2147483647"
	then
		su -c device_config put activity_manager max_phantom_processes 2147483647
	fi
fi		


#check if external storage is present
if [ -n "$(su -c ls -A /mnt/media_rw)" ]
then
	EXTERNAL_STORAGE=/mnt/media_rw/$(sudo ls /mnt/media_rw)
fi


#This function contains the commands required to start a Xwayland server which the chroot can connect to.

edit-config(){

if [ ! -f $CONTAINERS_DIR/$LAST_ARGUMENT.conf ]
then
	echo "No valid container has been provided, leaving now"
	exit
fi

if [ "${argslist[2]}" == "--mark-default" ]
then
	mark-default
elif [ "${argslist[2]}" == "--set-username" ]
then
	sed -i "3s/=.*/=${argslist[3]}/g" $CONTAINERS_DIR/$LAST_ARGUMENT.conf
elif [ "${argslist[2]}" == "--set-path" ]
then
	sed -i "1s|=.*|=${argslist[3]}|g" $CONTAINERS_DIR/$LAST_ARGUMENT.conf
fi
	
}

xserver(){

echo "Creating the socket"

su -c mkdir -p $CHROOT_DIR/tmp/runtime-$USERNAME
su -c mkdir -p $CHROOT_DIR/tmp/.X11-unix
su -c chmod 1777 $CHROOT_DIR/tmp/.X11-unix
mkdir -p $TMPDIR/.X11-unix
su -c busybox chroot $CHROOT_DIR "/bin/su - root -c 'chown $USERNAME:$USERNAME /tmp/runtime-$USERNAME'"
taskset -c 4-7 termux-x11 --no-xwayland-start & 
Xvfb :0 -ac -listen tcp :0.0 -screen 0 4096x4096x24 &
sleep 7
su -c busybox mount --bind $CHROOT_DIR/tmp/.X11-unix $TMPDIR/.X11-unix

}

virgl_server(){

echo "Creating the virgl socket"
MESA_NOERROR=1 virgl_test_server_android --use-egl-surfaceless & >/dev/null 2>&1
sleep 4
su -c busybox touch $CHROOT_DIR/tmp/.virgl_test
su -c busybox mount --bind $TMPDIR/.virgl_test $CHROOT_DIR/tmp/.virgl_test
su -c chmod a+rwx $CHROOT_DIR/tmp/.virgl_test
	
}

#function to update this script
update(){

git clone https://raw.githubusercontent.com/Pipetto-crypto/Chroot-Installer/master/chroot-launcher?token=GHSAT0AAAAAABZCGT55FGO2FJPUZ3DSSD5OY7REUIA
chmod +x chroot_launcher
mv chroot_launcher $PATH
	
}

#function that list installed containers
list-containers(){

for i in $CONTAINERS_DIR/*
do
	CONTAINER=$(basename -- $i)
	echo "${CONTAINER%.*}"
done
	
}

#from a config file, return the container name belonging to it
get_container(){
	
strippedconfig=$(basename -- $1)
echo "${strippedconfig%.*}"
	
}

check_parameters(){

exitcode=1

for i in $1
do
	position=1
	for e in $2
	do
		if [ "$i" == "$e" ]
		then
			exitcode=0
			break 2
		fi
	position=$((position+1))
	done
done

return $exitcode

}


#function that marks one container as default
mark-default(){

for i in $CONTAINERS_DIR/* #check each file for default flag and remove it
do
	if [ "$(tail -n 1 $i)" == "default" ]
	then
		sed -i '$ d' $i
	fi
done	

echo "default" >> $CONTAINERS_DIR/$LAST_ARGUMENT.conf
	
}

#function that start the chroot
start(){

containerslist=$(list-containers)

#check if a container is already running and so start it
if [ -f "$CONFIG_DIR/running.txt" ]
then
    runningcontainer=$(cat $CONFIG_DIR/running.txt)
    if [ -f $runningcontainer ] || [ -d $runningcontainer ]
    then
        ISRUNNING=true
    else
        CONFIG=$CONTAINERS_DIR/$runningcontainer.conf
        USERNAME=$(cat $CONFIG | awk -F '='  '/USERNAME/{print $2}')
        INSPATH=$(cat $CONFIG | awk -F '=' '/INSPATH/{print $2}')
        ISRUNNING=true
    fi

elif [ -f $LAST_ARGUMENT  ] || [ -d $LAST_ARGUMENT ] #check if last argument was a file or a directory
then
	INSPATH=$LAST_ARGUMENT
	USERNAME=""
	CONFIG=""

#check if last argument was start or restart or -w option to know if you didn't provide any container argument
elif ! check_parameters "$containerslist" "${argslist[*]}"
then

	if (( $(ls -1 $CONTAINERS_DIR | wc -l ) == 1 )) #check the number of available containers and if there is only one start it
	then
		CONFIG="$CONTAINERS_DIR/*"
		USERNAME=$(cat $CONFIG | awk -F '='  '/USERNAME/{print $2}')
		INSPATH=$(cat $CONFIG | awk -F '=' '/INSPATH/{print $2}')
		
	else  #if there are more than one container start the default

		DEFAULTFOUND=false
		for i in $CONTAINERS_DIR/*
		do
			if [ "$(tail -n 1 $i)" == "default" ]
			then
				DEFAULTFOUND=true
				CONFIG="$i"
				USERNAME=$(cat $CONFIG | awk -F '='  '/USERNAME/{print $2}')
				INSPATH=$(cat $CONFIG | awk -F '=' '/INSPATH/{print $2}')
			fi
		done
		if [ "$DEFAULTFOUND" == "false" ]
		then
			echo -e "No default container found, mark one as default or start with a container"
			exit
		fi
	fi		
#try to start the container provided by container argument		
else
	CONFIG="$CONTAINERS_DIR/$LAST_ARGUMENT.conf"
	USERNAME=$(cat $CONFIG | awk -F '='  '/USERNAME/{print $2}')
	INSPATH=$(cat $CONFIG | awk -F '=' '/INSPATH/{print $2}')
fi

if [ "$USERNAME" == "" ]
then
      USERNAME=root
fi


#check if user has prompted for a custom username
if check_parameters "-u" "${argslist[*]}"
then
	USERNAME=${argslist[$((position+1))]}
fi

 if [ "$ISRUNNING" == "false" ]
 then      
 	#check that the container provided is valid and in case exit
 	if [ "$INSPATH" == "" ]
 	then
 	    echo -e "This container seems to be damaged, exiting for safety"
 	    exit
 	fi

	if [ -f $INSPATH ]
	then
	    INSMETHOD="file"
	elif [ -d $INSPATH ]
	then
	    INSMETHOD="folder"
	else
	    echo -e "The container installation path doesn't seem to exist so I can't start it.Exiting"
	    exit
	fi

	#Start audio in the chroot
	echo -e "\nInitializing the audio server"
		pulseaudio --start --exit-idle-time=-1
		pacmd load-module module-native-protocol-tcp auth-ip-acl=127.0.0.1
		
	echo -e "\nStarting the chroot"
#Mount the container based on installation method		
		if findmnt $CHROOT_DIR >/dev/null
		then
		    su -c umount -d -l $CHROOT_DIR
		fi
		if [ "$INSMETHOD" == "file" ]
		then
			su -c busybox mount -o loop $INSPATH $CHROOT_DIR
		else
			su -c busybox mount --bind $INSPATH $CHROOT_DIR
			su -c busybox mount -o remount,bind,suid,exec $CHROOT_DIR
		fi
		for i in dev proc sys dev/pts dev/tty
		do
		    su -c busybox mount --bind /$i $CHROOT_DIR/$i
		done

#Mount internal storage in chroot location /media/internal_storage
	echo -e "\nBinding internal storage"
        su -c mkdir -p $CHROOT_DIR/media/internal_storage
		su -c /data/data/com.termux/files/usr/bin/bindfs -o perms=a+rwx --multithreaded $INTERNAL_STORAGE $CHROOT_DIR/media/internal_storage

#Check if available then mount external storage in /media/external_storage
		if [ -n "$(sudo ls -A /mnt/media_rw)" ]
		then
			echo -e "\nBinding external storage"
			su -c mkdir -p $CHROOT_DIR/media/external_storage
			su -c /data/data/com.termux/files/usr/bin/bindfs -o perms=a+rwx --multithreaded $EXTERNAL_STORAGE $CHROOT_DIR/media/external_storage
		else
			echo -e "\nSD card is not present, won't mount external storage"
		fi
	
#check if binfmt_misc support is available in kernel and binfmt-support package is installed
	if [ -d /proc/sys/fs/binfmt_misc ] && [ -f $CHROOT_DIR/usr/sbin/update-binfmts ]
	then
		su -c busybox mount --bind /proc/sys/fs/binfmt_misc $CHROOT_DIR/proc/sys/fs/binfmt_misc
		echo -e "\nLoading binfmts entries"
		su -c busybox chroot $CHROOT_DIR "/bin/su - root -c '/usr/sbin/update-binfmts --enable'"
	else 
		echo -e "\nBinfmt support not detected or missing binfmt-support package, skipping loading of binfmt entries"
	fi
	
	
	if check_parameters "-x" "${argslist[*]}"
	then
			xserver #calls the xserver function if the -x option is provided
	fi

	if check_parameters "-v" "${argslist[*]}"
	then
	        virgl_server #calls the xserver function if the -x option
	fi
	
	echo -e "\nAll preparations completed, connecting now\n"
	#check if login binary is available else default to an alternative method to access the chroot
	if su -c ls $CHROOT_DIR/bin | grep -q login
	then
		#We check if config exists, if it doesn't it means a custom rootfs has been used
		if [ "$CONFIG" == "" ]
		then
			runningcontainer=$INSPATH
			echo "$runningcontainer" > $CONFIG_DIR/running.txt
			su -c busybox chroot $CHROOT_DIR /bin/login -f $USERNAME
		else
			runningcontainer=$(get_container $CONFIG)
			echo "$runningcontainer" > $CONFIG_DIR/running.txt
			su -c busybox chroot $CHROOT_DIR /bin/login -f $USERNAME
		fi
	else
	    su -c busybox chroot $CHROOT_DIR /bin/sh
	fi
else
	echo -e "Chroot already mounted, logging in"
	if su -c ls $CHROOT_DIR/bin | grep -q login
	then
		su -c busybox chroot $CHROOT_DIR /bin/login -f $USERNAME
	else
		su -c busybox chroot $CHROOT_DIR /bin/sh
	fi
fi

}

#function to stop the chroot
stop(){

rm -rf $CONFIG_DIR/running.txt
if findmnt $CHROOT_DIR >/dev/null
then
	#kill termux-x11 app process
	su -c kill $(pidof app_process) 
	su -c kill $(pidof virgl_test_server_android)
	su -c umount -d -l $CHROOT_DIR
else
	echo -e "\nNo container seems to be mounted, exiting"
fi


}

#Function that implements a help message
help(){


optscolumn1=(
"start"
"-x"
"stop"
"restart"
"update"
"list-containers"
"mark-default"
"help"
)

optscolumn2=(
"launch the container specified by argument containername or chroot into the rootfs specified by argument filepath. If no container or filepath is provided it launches the one marked as default"
"start a Xserver server through Termux:X11, to use only with start or restart"
"stop any running container then exit"
"restart the container specified by argument containername, takes same options as start"
"update this launcher script then exit"
"list available containers then exit"
"mark container specified by argument container name as default"
"print this help message then exit"
)



echo -e "chroot-launcher: chroot-launcher [start|stop|restart|list-containers|mark-default] [-w] containername|filepath"
echo -e "\nA launcher intended mainly for chroot-containers made with the utility chroot-installer, even though it can chroot into every rootfs as long as a full path to it is provided. The chroot is launched with audio, internal, and if available external storage by default"
echo -e "\nOptions:\n"
paste <(printf "%-20s\n" "${optscolumn1[@]}") <(printf "%-20s\n" "${optscolumn2[@]}")
echo -e "\nArguments:\n"
echo -e "\ncontainername     name of the container to be launched"
echo -e "\nfilepath          path to the rootfs that the script should try to launch, used in place of containername"

}

while [ True ];
do
	
	if [ "${argslist[1]}" == "stop" ]
	then
		stop
		break
	elif [ "${argslist[1]}" == "start" ]
    then
    	start 
		break
	elif [ "${argslist[1]}" == "restart" ]
	then
		stop
		start
		break
	elif [ "${argslist[1]}" == "update" ]
	then
		update
		break
	elif [ "${argslist[1]}" == "list-containers" ]
	then
		list-containers
		break
	elif [ "${argslist[1]}" == "mark-default" ]
	then
		mark-default
		break
	elif [ "${argslist[1]}" == "help" ]
	then
		help
		break
	elif [ "${argslist[1]}" == "edit-conf" ]
	then
		edit-config
		break
    else  
		echo -e "\nNo option specified\n"
		help
        break
	fi	

done


